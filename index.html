<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>2GIS –ù–∞–≤–∏–≥–∞—Ü–∏—è ‚Äî –ë–∏—à–∫–µ–∫</title>
    <script src="https://mapgl.2gis.com/api/js/v1"></script>
      <meta name="apple-mobile-web-app-capable" content="yes" />
    <style>
        html,
        body,
        #map {
            margin: 0;
            width: 100%;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            font-family: sans-serif;
            z-index: 10;
        }

        #infoPanel {
            position: absolute;
            top: 170px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 6px;
            font-family: monospace;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            z-index: 10;
            white-space: pre-line;
        }

        button,
        select {
            margin-top: 5px;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        button {
            background: #0078ff;
            color: white;
            border: none;
            cursor: pointer;
        }

        #startButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 30px;
            font-size: 16px;
            display: none;
            /* Initially hidden */
        }

        #toggle3dButton {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
    </style>
</head>

<body>
    <div id="controls">
        <div><b>–¢–∏–ø –º–∞—Ä—à—Ä—É—Ç–∞:</b>
            <select id="direction-type">
                <option value="carrouting">–ê–≤—Ç–æ</option>
                <option value="truck">–ì—Ä—É–∑–æ–≤–æ–π</option>
            </select>
        </div>
        <div style="margin-top:6px">
            <b>–ú–∞—Ä—à—Ä—É—Ç:</b>
            <select id="active-direction"></select>
        </div>
        <button id="resetButton" style="margin-top:8px">–°–±—Ä–æ—Å–∏—Ç—å</button>
    </div>

    <div id="infoPanel">üöó –û–∂–∏–¥–∞–Ω–∏–µ —Ç–æ—á–µ–∫...</div>
    <div id="map"></div>
    <button id="startButton">–ù–∞—á–∞—Ç—å –Ω–∞–≤–∏–≥–∞—Ü–∏—é</button>
    <button id="toggle3dButton">2D/3D</button>

    <script>
        const key = "e485191c-43bc-4296-8a7b-b671df9ceedd";
        const map = new mapgl.Map("map", {
            key, center: [74.612, 42.874], zoom: 13, pitch: 45, rotation: 35,
        });

        let points = [];
        let markers = [];
        let drawnRoutes = [];
        let directionsResult = [];
        let activeRouteIndex = 0;
        let movingMarker = null;
        let simulationInterval = null;
        let currentIndex = 0;
        let coordinates = []; // –≥–ª–æ–±–∞–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤ —Ç–µ–∫—É—â–µ–≥–æ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –º–∞—Ä—à—Ä—É—Ç–∞
        let travelledDistance = 0;
        let previousPolyline = null;

        // –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –ø–æ—Å–ª–µ –æ–±—ä—è–≤–ª–µ–Ω–∏—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
        let watchId = null;
        let userMarker = null;

        const directionTypeSelector = document.getElementById("direction-type");
        const directionItemSelector = document.getElementById("active-direction");
        const resetButton = document.getElementById("resetButton");
        const infoPanel = document.getElementById("infoPanel");
        const startButton = document.getElementById("startButton");
        const toggle3dButton = document.getElementById("toggle3dButton");

        let is3dMode = true;
        let isNavigating = false;
        let cameraFollowing = true;

        // –ó–∞–º–µ–Ω–∏—Ç–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É
        map.on("click", (e) => {
            const [lng, lat] = e.lngLat;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —É–∂–µ —Ç–æ—á–∫–∞ –ê (–∏–∑ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏)
            if (points.length === 0) {
                // –ï—Å–ª–∏ –Ω–µ—Ç —Ç–æ—á–∫–∏ –ê, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â—É—é –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é
                if (userMarker) {
                    const coords = userMarker.getCoordinates();
                    points.push({ x: coords[0], y: coords[1] });
                } else {
                    points.push({ x: lng, y: lat });
                }
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ—á–∫—É –ë (–ø—É–Ω–∫—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è)
            if (points.length === 1) {
                points.push({ x: lng, y: lat });
                // –°–æ–∑–¥–∞–µ–º –∫—Ä–∞—Å–Ω—ã–π –º–∞—Ä–∫–µ—Ä –¥–ª—è —Ç–æ—á–∫–∏ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è
                const marker = new mapgl.Marker(map, {
                    coordinates: [lng, lat],
                    color: "red",
                });
                markers.push(marker);
                // –°—Ç—Ä–æ–∏–º –º–∞—Ä—à—Ä—É—Ç
                getDirection(directionTypeSelector.value);
            }
        });

        // –î–æ–±–∞–≤—å—Ç–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è —Ç–∞—á-—Å–æ–±—ã—Ç–∏–π
        map.on("touchend", (e) => {
            e.preventDefault(); // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ
            const touch = e.touches[0] || e.changedTouches[0];
            if (touch) {
                const point = map.unproject([touch.clientX, touch.clientY]);
                if (point) {
                    const [lng, lat] = [point.lng, point.lat];
                    // –¢–∞–∫–∞—è –∂–µ –ª–æ–≥–∏–∫–∞, –∫–∞–∫ –∏ –≤ –∫–ª–∏–∫–µ
                    if (points.length === 0) {
                        if (userMarker) {
                            const coords = userMarker.getCoordinates();
                            points.push({ x: coords[0], y: coords[1] });
                        } else {
                            points.push({ x: lng, y: lat });
                        }
                    }
                    if (points.length === 1) {
                        points.push({ x: lng, y: lat });
                        const marker = new mapgl.Marker(map, {
                            coordinates: [lng, lat],
                            color: "red",
                        });
                        markers.push(marker);
                        getDirection(directionTypeSelector.value);
                    }
                }
            }
        });

        resetButton.onclick = () => {
            points = [];
            markers.forEach(m => m.destroy());
            markers = [];
            clearRoutes();
            if (movingMarker) movingMarker.destroy();
            clearInterval(simulationInterval);
            infoPanel.textContent = "üöó –û–∂–∏–¥–∞–Ω–∏–µ —Ç–æ—á–µ–∫...";
            directionItemSelector.innerHTML = "";
            previousPolyline = null;
            isNavigating = false;
            startButton.style.display = "none";
            if (is3dMode) {
                map.setPitch(45);
                map.setZoom(13);
                map.setRotation(35);
            }
            if (userMarker) {
                userMarker.destroy();
                userMarker = null;
            }
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            points = [];
            startGeolocation(); // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é
        };

        directionTypeSelector.onchange = () => {
            if (points.length === 2) getDirection(directionTypeSelector.value);
        };

        directionItemSelector.onchange = () => {
            activeRouteIndex = Number(directionItemSelector.value);
            redrawRoutes();
        };

        async function getDirection(type) {
            resetButton.textContent = "–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ...";
            const body = getQuery(type);
            const response = await fetch(`https://catalog.api.2gis.ru/${type}/6.0.0/global?key=${key}`, {
                method: "POST", body: JSON.stringify(body),
            });
            const json = await response.json();
            directionsResult = Array.isArray(json.result) ? json.result : [];
            directionItemSelector.innerHTML = directionsResult.map((_, i) => `<option value="${i}">${i}</option>`).join("");
            activeRouteIndex = 0;
            directionItemSelector.value = 0;
            redrawRoutes();
            resetButton.textContent = "–°–±—Ä–æ—Å–∏—Ç—å";
            startButton.style.display = "block"; // Show start button when route is ready
        }

        function getQuery(type) {
            const [a, b] = points;
            return {
                type: type === "truck" ? "truck_jam" : "jam",
                locale: "ru",
                points: [
                    { x: a.x, y: a.y, type: "pedo" },
                    { x: b.x, y: b.y, type: "pedo" },
                ],
            };
        }

        function clearRoutes() {
            drawnRoutes.forEach(r => r.polylines.forEach(p => p.destroy()));
            drawnRoutes = [];
        }

        function redrawRoutes() {
            clearRoutes();
            directionsResult.forEach((r, i) => drawnRoutes.push(drawRoute(r, i)));
            startSimulation(); // –∑–∞–ø—É—Å–∫–∞–µ–º —Å–∏–º—É–ª—è—Ü–∏—é –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –º–∞—Ä—à—Ä—É—Ç–∞
        }

        function drawRoute(route, index) {
            const isActive = index === activeRouteIndex;
            const color = isActive ? '#0078ff' : '#bfbfbf';
            const drawn = { polylines: [] };
            route.maneuvers.forEach(m => {
                if (m.outcoming_path) {
                    m.outcoming_path.geometry.forEach(g => {
                        const p = new mapgl.Polyline(map, {
                            coordinates: parseWKT(g.selection),
                            color, width: 8, opacity: isActive ? 1 : 0.4,
                        });
                        drawn.polylines.push(p);
                    });
                }
            });
            return drawn;
        }

        function parseWKT(wkt) {
            return wkt.slice("LINESTRING(".length, -1)
                .split(",")
                .map(c => c.trim().split(" ").map(Number));
        }

        // –û—Å—Ç–∞–≤–ª—è–µ–º –Ω–∞ –∫–∞—Ä—Ç–µ —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç (—É–¥–∞–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ)
        function keepOnlyActiveRoute(index) {
            // –±–µ–∑–æ–ø–∞—Å–Ω–æ: –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–Ω—ã–µ –º–∞—Ä—à—Ä—É—Ç—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç directionsResult –∏–Ω–¥–µ–∫—Å–∞–º
            drawnRoutes.forEach((r, i) => {
                if (i !== index) {
                    r.polylines.forEach(p => p.destroy());
                }
            });
            // –ø–µ—Ä–µ–ø—Ä–∏–≤—è–∑–∞—Ç—å drawnRoutes –∫ –æ–¥–Ω–æ–º—É –∞–∫—Ç–∏–≤–Ω–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É (–µ—Å–ª–∏ –µ—Å—Ç—å)
            if (drawnRoutes[index]) {
                drawnRoutes = [drawnRoutes[index]];
            } else {
                drawnRoutes = [];
            }
        }

        // –°–∏–º—É–ª—è—Ü–∏—è
        const ANIMATION_INTERVAL = 100; // –£–≤–µ–ª–∏—á–µ–Ω–æ —Å 16 –¥–æ 100–º—Å
        const ANIMATION_STEP = 0.1;    // –£–≤–µ–ª–∏—á–µ–Ω–æ —Å 0.02 –¥–æ 0.1
        const ANIMATION_DURATION = 2000; // 2 —Å–µ–∫—É–Ω–¥—ã –Ω–∞ —Å–µ–≥–º–µ–Ω—Ç –ø—É—Ç–∏
        const FOLLOW_DISTANCE = 0.0003;  // –£–º–µ–Ω—å—à–µ–Ω–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ —Å–ª–µ–¥–æ–≤–∞–Ω–∏—è
        const FOLLOW_ZOOM = 18;          // –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –∑—É–º –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
        const CAMERA_LAG = 0.1; // Camera smoothing factor (0-1)
        const CAMERA_UPDATE_INTERVAL = 300; // –ù–æ–≤–∞—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã

        // –î–æ–±–∞–≤—å—Ç–µ —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è throttling
        function throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            }
        }

        function interpolateCoordinates(coord1, coord2, t) {
            return [
                coord1[0] + (coord2[0] - coord1[0]) * t,
                coord1[1] + (coord2[1] - coord1[1]) * t,
            ];
        }

        function startSimulation() {
            clearInterval(simulationInterval);
            if (movingMarker) movingMarker.destroy();

            const activeRoute = directionsResult[activeRouteIndex];
            if (!activeRoute) return;

            // –°–æ–±–∏—Ä–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –º–∞—Ä—à—Ä—É—Ç–∞
            coordinates = [];
            activeRoute.maneuvers.forEach(m => {
                if (m.outcoming_path) {
                    m.outcoming_path.geometry.forEach(g => {
                        coordinates.push(...parseWKT(g.selection));
                    });
                }
            });

            if (coordinates.length < 2) return;

            // –°–æ–∑–¥–∞–µ–º –º–∞—Ä–∫–µ—Ä
            movingMarker = new mapgl.Marker(map, {
                coordinates: coordinates[0],
                icon: "https://cdn-icons-png.flaticon.com/512/744/744465.png",
                size: [28, 28],
            });

            currentIndex = 0;
            travelledDistance = 0;
            const total = totalDistance(coordinates);

            function animateSegment(startTime) {
                const elapsedTime = performance.now() - startTime;
                const t = elapsedTime / ANIMATION_DURATION;

                if (currentIndex >= coordinates.length - 1) {
                    infoPanel.textContent = "‚úÖ –ú–∞—Ä—à—Ä—É—Ç –∑–∞–≤–µ—Ä—à–µ–Ω!";
                    isNavigating = false;
                    return;
                }

                if (t < 1) {
                    // –ò–Ω—Ç–µ—Ä–ø–æ–ª–∏—Ä—É–µ–º —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é
                    const newCoords = interpolateCoordinates(
                        coordinates[currentIndex],
                        coordinates[currentIndex + 1],
                        t
                    );
                    
                    movingMarker.setCoordinates(newCoords);
                    
                    if (isNavigating) {
                        // –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–º–µ—Ä—É
                        const bearing = getBearing(
                            coordinates[currentIndex],
                            coordinates[currentIndex + 1]
                        );
                        
                        // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∫–∞–º–µ—Ä—É –ø–æ–∑–∞–¥–∏ –º–∞—Ä–∫–µ—Ä–∞
                        const rad = (bearing * Math.PI / 180);
                        const cameraPos = [
                            newCoords[0] - FOLLOW_DISTANCE * Math.sin(rad),
                            newCoords[1] - FOLLOW_DISTANCE * Math.cos(rad)
                        ];
                        
                        map.setCenter(cameraPos);
                        if (is3dMode) {
                            map.setRotation(bearing);
                            map.setPitch(60);
                            map.setZoom(FOLLOW_ZOOM);
                        }
                    }

                    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
                    const segmentProgress = distance(coordinates[currentIndex], newCoords);
                    travelledDistance = total * (currentIndex / (coordinates.length - 1)) + segmentProgress;
                    const remaining = total - travelledDistance;
                    const progress = (travelledDistance / total) * 100;

                    updateInfoPanel(activeRoute, newCoords, travelledDistance, remaining, progress);
                    
                    requestAnimationFrame(() => animateSegment(startTime));
                } else {
                    // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Å–µ–≥–º–µ–Ω—Ç—É
                    currentIndex++;
                    if (currentIndex < coordinates.length - 1) {
                        animateSegment(performance.now());
                    }
                }
            }

            // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
            if (coordinates.length > 1) {
                animateSegment(performance.now());
            }
        }

        // –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–∏ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–µ—Ä–µ–¥ startSimulation()

        function totalDistance(coords) {
            let total = 0;
            for (let i = 0; i < coords.length - 1; i++) {
                total += distance(coords[i], coords[i + 1]);
            }
            return total;
        }

        function distance(point1, point2) {
            // Haversine formula
            const R = 6371; // Earth's radius in km
            const lat1 = point1[1] * Math.PI / 180;
            const lat2 = point2[1] * Math.PI / 180;
            const dLat = (point2[1] - point1[1]) * Math.PI / 180;
            const dLon = (point2[0] - point1[0]) * Math.PI / 180;

            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1) * Math.cos(lat2) *
                     Math.sin(dLon/2) * Math.sin(dLon/2);
            
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // ---- –ù–û–í–´–ô updateInfoPanel: –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Å—á–∏—Ç–∞–µ—Ç –ø–æ–≤–æ—Ä–æ—Ç—ã –ø–æ –≤–µ–∫—Ç–æ—Ä–∞–º ----
        function updateInfoPanel(route, currentPosition, travelledDistance, remaining, progress) {
            const maneuvers = route.maneuvers;
            let nextManeuver = null;
            let distanceToNextManeuver = Infinity;
            let nextManeuverAnchor = null; // —Ç–æ—á–∫–∞ —è–∫–æ—Ä—è –º–∞–Ω—ë–≤—Ä–∞ (–≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö)
            let nextManeuverIndexInCoords = -1; // –∏–Ω–¥–µ–∫—Å –≤ –≥–ª–æ–±–∞–ª—å–Ω–æ–º coordinates

            // –∏—â–µ–º –±–ª–∏–∂–∞–π—à–∏–π –º–∞–Ω—ë–≤—Ä –ø–æ —Å—Ç–∞—Ä—Ç–æ–≤–æ–π —Ç–æ—á–∫–µ –µ–≥–æ outcoming_path
            for (const man of maneuvers) {
                if (!man.outcoming_path?.geometry?.length) continue;

                // –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—É—é —Ç–æ—á–∫—É –ø–µ—Ä–≤–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞ –∫–∞–∫ "–º–µ—Å—Ç–æ –Ω–∞—á–∞–ª–∞" –º–∞–Ω—ë–≤—Ä–∞ (anchor)
                const firstSegment = man.outcoming_path.geometry[0];
                const segCoords = parseWKT(firstSegment.selection);
                const anchor = segCoords[0]; // –Ω–∞—á–∞–ª–æ —Å–µ–≥–º–µ–Ω—Ç–∞ ‚Äî –≥–¥–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –º–∞–Ω—ë–≤—Ä

                const d = distance(currentPosition, anchor);
                if (d < distanceToNextManeuver && d > 0.0001) {
                    distanceToNextManeuver = d;
                    nextManeuver = man;
                    nextManeuverAnchor = anchor;
                }
            }

            // –µ—Å–ª–∏ –Ω–∞—à–ª–∏ –º–∞–Ω—ë–≤—Ä ‚Äî –ø–æ–ø—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –µ–≥–æ –∏–Ω–¥–µ–∫—Å –≤ –æ–±—â–µ–º –º–∞—Å—Å–∏–≤–µ coordinates
            if (nextManeuver && nextManeuverAnchor) {
                nextManeuverIndexInCoords = findClosestIndex(nextManeuverAnchor, coordinates);
            }

            // –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–∞–Ω—ë–≤—Ä–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ–º —É–≥–ª–∞ –º–µ–∂–¥—É –ø—Ä–µ–¥—ã–¥—É—â–∏–º –∏ —Å–ª–µ–¥—É—é—â–∏–º–∏ –≤–µ–∫—Ç–æ—Ä–∞–º–∏
            let maneuverText = '–î–≤–∏–≥–∞–π—Ç–µ—Å—å –ø—Ä—è–º–æ';
            if (nextManeuver && nextManeuverIndexInCoords !== -1) {
                const idx = nextManeuverIndexInCoords;
                // –≤–æ–∑—å–º—ë–º –ø—Ä–µ–¥—ã–¥—É—â—É—é —Ç–æ—á–∫—É, —Ç–µ–∫—É—â—É—é (anchor) –∏ —Å–ª–µ–¥—É—é—â—É—é —Ç–æ—á–∫—É (–µ—Å–ª–∏ –µ—Å—Ç—å)
                const prev = coordinates[Math.max(0, idx - 1)];
                const cur = coordinates[idx];
                const next = coordinates[Math.min(coordinates.length - 1, idx + 1)];

                const turn = computeTurnDirection(prev, cur, next); // 'left'|'right'|'straight'|'uturn'
                switch (turn) {
                    case 'right': maneuverText = '–ü–æ–≤–µ—Ä–Ω–∏—Ç–µ –Ω–∞–ª–µ–≤–æ'; break;
                    case 'left': maneuverText = '–ü–æ–≤–µ—Ä–Ω–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–æ'; break;
                    case 'uturn': maneuverText = '–†–∞–∑–≤–µ—Ä–Ω–∏—Ç–µ—Å—å'; break;
                    default: maneuverText = '–î–≤–∏–≥–∞–π—Ç–µ—Å—å –ø—Ä—è–º–æ';
                }
            } else if (nextManeuver?.turn_direction) {
                // fallback ‚Äî –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –≤—ã—á–∏—Å–ª–∏—Ç—å, –∏—Å–ø–æ–ª—å–∑—É–µ–º turn_direction –æ—Ç API
                switch (nextManeuver.turn_direction) {
                    case 'right': maneuverText = '–ü–æ–≤–µ—Ä–Ω–∏—Ç–µ –Ω–∞–ª–µ–≤–æ'; break;
                    case 'left': maneuverText = '–ü–æ–≤–µ—Ä–Ω–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–æ'; break;
                    case 'slight_left': maneuverText = '–ü–ª–∞–≤–Ω–æ –Ω–∞–ª–µ–≤–æ'; break;
                    case 'slight_right': maneuverText = '–ü–ª–∞–≤–Ω–æ –Ω–∞–ø—Ä–∞–≤–æ'; break;
                    case 'uturn': maneuverText = '–†–∞–∑–≤–µ—Ä–Ω–∏—Ç–µ—Å—å'; break;
                    default: maneuverText = '–î–≤–∏–≥–∞–π—Ç–µ—Å—å –ø—Ä—è–º–æ';
                }
            }

            const distanceAhead = isFinite(distanceToNextManeuver) ? distanceToNextManeuver * 1000 : 0;
            const info = distanceAhead > 50
                ? `–ß–µ—Ä–µ–∑ ${distanceAhead.toFixed(0)} –º ${maneuverText.toLowerCase()}`
                : maneuverText;

            infoPanel.textContent =
                `${info}\n` +
                `–ü—Ä–æ–π–¥–µ–Ω–æ: ${travelledDistance.toFixed(2)} –∫–º\n` +
                `–û—Å—Ç–∞–ª–æ—Å—å: ${remaining.toFixed(2)} –∫–º\n` +
                `–ü—Ä–æ–≥—Ä–µ—Å—Å: ${progress.toFixed(1)}%`;
        }

        // –ù–∞—Ö–æ–¥–∏—Ç –∏–Ω–¥–µ–∫—Å –±–ª–∏–∂–∞–π—à–µ–π —Ç–æ—á–∫–∏ –≤ –º–∞—Å—Å–∏–≤–µ coords –∫ —Ç–æ—á–∫–µ p
        function findClosestIndex(p, coords) {
            if (!coords || coords.length === 0) return -1;
            let best = -1;
            let bestD = Infinity;
            for (let i = 0; i < coords.length; i++) {
                const d = distance(p, coords[i]);
                if (d < bestD) {
                    bestD = d;
                    best = i;
                }
            }
            return best;
        }

        // –í—ã—á–∏—Å–ª—è–µ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–≤–æ—Ä–æ—Ç–∞ –ø–æ —Ç—Ä—ë–º —Ç–æ—á–∫–∞–º (prev, cur, next)
        // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: 'left' | 'right' | 'straight' | 'uturn'
        function computeTurnDirection(prev, cur, next) {
            if (!prev || !cur || !next) return 'straight';

            // Calculate bearings
            const bearing1 = getBearing(prev, cur);
            const bearing2 = getBearing(cur, next);

            // Calculate turn angle
            let angle = bearing2 - bearing1;
            if (angle < -180) angle += 360;
            if (angle > 180) angle -= 360;

            // Determine turn direction
            if (Math.abs(angle) < 20) return 'straight';
            if (Math.abs(angle) > 150) return 'uturn';

            return angle > 0 ? 'right' : 'left';
        }

        // Calculate bearing between two points
        function getBearing(start, end) {
            const startLat = start[1] * Math.PI / 180;
            const startLng = start[0] * Math.PI / 180;
            const endLat = end[1] * Math.PI / 180;
            const endLng = end[0] * Math.PI / 180;

            const dLng = endLng - startLng;
            const y = Math.sin(dLng) * Math.cos(endLat);
            const x = Math.cos(startLat) * Math.sin(endLat) -
                     Math.sin(startLat) * Math.cos(endLat) * Math.cos(dLng);
            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360;
        }

        // Modified startSimulation
        startButton.onclick = () => {
            // Get coordinates from active route first
            coordinates = [];
            const activeRoute = directionsResult[activeRouteIndex];
            if (!activeRoute) return;

            activeRoute.maneuvers.forEach(m => {
                if (m.outcoming_path) {
                    m.outcoming_path.geometry.forEach(g => {
                        const points = parseWKT(g.selection);
                        coordinates.push(...points);
                    });
                }
            });

            // Initialize view only if we have coordinates
            if (!initializeNavigationView()) {
                console.error('Failed to initialize navigation view - invalid coordinates');
                return;
            }

            isNavigating = true;
            startButton.style.display = "none";
            startSimulation();
        };

        // Add this helper function before startButton.onclick
        function initializeNavigationView() {
            if (!coordinates || coordinates.length < 2) return false;
            
            const start = coordinates[0];
            const next = coordinates[1];
            if (!start || !next) return false;

            if (is3dMode) {
                const bearing = getBearing(start, next);
                
                // Position camera directly behind start point
                const rad = (bearing * Math.PI / 180);
                const cameraPos = [
                    start[0] - FOLLOW_DISTANCE * Math.sin(rad),
                    start[1] - FOLLOW_DISTANCE * Math.cos(rad)
                ];
                
                map.setCenter(cameraPos);
                map.setZoom(FOLLOW_ZOOM);
                map.setRotation(bearing);
                map.setPitch(60);
            }
            return true;
        }

        // New function to handle 3D toggle
        toggle3dButton.onclick = () => {
            is3dMode = !is3dMode;
            map.setPitch(is3dMode ? 45 : 0);
            if (isNavigating && is3dMode) {
                followMarker();
            }
        };

        // New function to follow marker
        const throttledFollowMarker = throttle(function(pos, bearing) {
            const rad = (bearing * Math.PI / 180);
            const cameraPos = [
                pos[0] - FOLLOW_DISTANCE * Math.sin(rad),
                pos[1] - FOLLOW_DISTANCE * Math.cos(rad)
            ];
            
            map.setCenter(cameraPos, { duration: CAMERA_UPDATE_INTERVAL });
            if (is3dMode) {
                map.setZoom(FOLLOW_ZOOM, { duration: CAMERA_UPDATE_INTERVAL });
                map.setRotation(bearing, { duration: CAMERA_UPDATE_INTERVAL });
                map.setPitch(60, { duration: CAMERA_UPDATE_INTERVAL });
            }
        }, CAMERA_UPDATE_INTERVAL);

        function followMarker() {
            if (!movingMarker || !cameraFollowing) return;
            
            const pos = movingMarker.getCoordinates();
            let bearing = 0;
            
            // Calculate bearing based on movement direction
            if (currentIndex < coordinates.length - 1) {
                const next = coordinates[currentIndex + 1];
                bearing = getBearing(pos, next);
            }
            
            throttledFollowMarker(pos, bearing);
        }

        // –î–æ–±–∞–≤—å—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –≥–µ–æ–ª–æ–∫–∞—Ü–∏–µ–π
        function startGeolocation() {
            if (!navigator.geolocation) {
                alert("–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤–∞—à–∏–º –±—Ä–∞—É–∑–µ—Ä–æ–º");
                return;
            }

            // –°–æ–∑–¥–∞–µ–º –º–∞—Ä–∫–µ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            userMarker = new mapgl.Marker(map, {
                coordinates: [0, 0],
                icon: "https://cdn-icons-png.flaticon.com/512/744/744465.png",
                size: [28, 28],
            });

            // –û–ø—Ü–∏–∏ –¥–ª—è –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏
            const options = {
                enableHighAccuracy: true,
                timeout: 5000,
                maximumAge: 0
            };

            // –ù–∞—á–∏–Ω–∞–µ–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
            watchId = navigator.geolocation.watchPosition(
                position => {
                    const { latitude, longitude } = position.coords;
                    const userPos = [longitude, latitude];
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –º–∞—Ä–∫–µ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    userMarker.setCoordinates(userPos);

                    // –ï—Å–ª–∏ —ç—Ç–æ –ø–µ—Ä–≤—ã–π —Ä–∞–∑ –∏–ª–∏ —Ç–æ—á–µ–∫ –µ—â—ë –Ω–µ—Ç
                    if (points.length === 0) {
                        points[0] = { x: longitude, y: latitude };
                        // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–∞—Ä—Ç—É –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
                        map.setCenter(userPos);
                        map.setZoom(15);
                    }

                    // –ï—Å–ª–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏—è –∞–∫—Ç–∏–≤–Ω–∞, –æ–±–Ω–æ–≤–ª—è–µ–º –º–∞—Ä—à—Ä—É—Ç
                    if (isNavigating) {
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –æ—Ç –º–∞—Ä—à—Ä—É—Ç–∞
                        const deviation = minDistanceToPath(userPos, coordinates);
                        if (deviation > 0.003) { // 3 –º–µ—Ç—Ä–∞
                            points[0] = { x: longitude, y: latitude };
                            getDirection(directionTypeSelector.value);
                        }
                    }
                },
                error => {
                    console.error('–û—à–∏–±–∫–∞ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏:', error);
                    alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –≤–∞—à–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ');
                },
                options
            );
        }

        // –û–±–Ω–æ–≤–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é reset
        resetButton.onclick = () => {
            // ...—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–¥...
            if (userMarker) {
                userMarker.destroy();
                userMarker = null;
            }
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            points = [];
            startGeolocation(); // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é
        };

        // –û–±–Ω–æ–≤–∏—Ç–µ startButton.onclick
        startButton.onclick = () => {
            isNavigating = true;
            startButton.style.display = "none";
            
            if (is3dMode) {
                map.setPitch(60);
                map.setZoom(FOLLOW_ZOOM);
            }
        };

        // –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–æ—Ç –∫–æ–¥ –≤ –∫–æ–Ω–µ—Ü —Å–∫—Ä–∏–ø—Ç–∞ –¥–ª—è –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–∞ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏
        document.addEventListener('DOMContentLoaded', () => {
            startGeolocation();
        });
    </script>
</body>

</html>
