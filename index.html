<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>2GIS –ù–∞–≤–∏–≥–∞—Ü–∏—è ‚Äî –ë–∏—à–∫–µ–∫</title>
    <script src="https://mapgl.2gis.com/api/js/v1"></script>
      <meta name="apple-mobile-web-app-capable" content="yes" />
    <style>
        html,
        body,
        #map {
            margin: 0;
            width: 100%;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            font-family: sans-serif;
            z-index: 10;
        }

        #infoPanel {
            position: absolute;
            top: 170px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 6px;
            font-family: monospace;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            z-index: 10;
            white-space: pre-line;
        }

        button,
        select {
            margin-top: 5px;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        button {
            background: #0078ff;
            color: white;
            border: none;
            cursor: pointer;
        }

        #startButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 30px;
            font-size: 16px;
            display: none;
            /* Initially hidden */
        }

        #toggle3dButton {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
    </style>
</head>

<body>
    <div id="controls">
        <div><b>–¢–∏–ø –º–∞—Ä—à—Ä—É—Ç–∞:</b>
            <select id="direction-type">
                <option value="carrouting">–ê–≤—Ç–æ</option>
                <option value="truck">–ì—Ä—É–∑–æ–≤–æ–π</option>
            </select>
        </div>
        <div style="margin-top:6px">
            <b>–ú–∞—Ä—à—Ä—É—Ç:</b>
            <select id="active-direction"></select>
        </div>
        <button id="resetButton" style="margin-top:8px">–°–±—Ä–æ—Å–∏—Ç—å</button>
    </div>

    <div id="infoPanel">üöó –û–∂–∏–¥–∞–Ω–∏–µ —Ç–æ—á–µ–∫...</div>
    <div id="map"></div>
    <button id="startButton">–ù–∞—á–∞—Ç—å –Ω–∞–≤–∏–≥–∞—Ü–∏—é</button>
    <button id="toggle3dButton">2D/3D</button>

    <script>
const key = "e485191c-43bc-4296-8a7b-b671df9ceedd";
const map = new mapgl.Map("map", {
    key, center: [74.612, 42.874], zoom: 13, pitch: 45, rotation: 35,
});

// state
let points = []; // [ {x,y} ]: A = points[0] from geolocation, B = points[1] from click
let markers = [];
let drawnRoutes = [];
let directionsResult = [];
let activeRouteIndex = 0;

let watchId = null;
let userMarker = null;
let pathCoords = []; // —Ä–µ–∞–ª—å–Ω—ã–π –ø—Ä–æ–π–¥–µ–Ω–Ω—ã–π –ø—É—Ç—å [ [lng,lat], ... ]
let previousPolyline = null;
let lastPos = null;
let travelledDistance = 0;

const directionTypeSelector = document.getElementById("direction-type");
const directionItemSelector = document.getElementById("active-direction");
const resetButton = document.getElementById("resetButton");
const infoPanel = document.getElementById("infoPanel");
const startButton = document.getElementById("startButton");
const toggle3dButton = document.getElementById("toggle3dButton");

let is3dMode = true;
let isNavigating = false;
let cameraFollowing = true;

const FOLLOW_DISTANCE = 0.0003; // degrees ~ ~30m depending; tuned for behind camera
const FOLLOW_ZOOM = 18;
const CAMERA_UPDATE_INTERVAL = 500;
const DEVIATION_THRESHOLD_KM = 0.01; // 10 meters = 0.01 km
const CAR_ICON = "https://i0.wp.com/apptractor.ru/wp-content/uploads/2017/04/navi.png";

// helpers
function throttle(func, limit) {
    let inThrottle = false;
    return (...args) => {
        if (!inThrottle) {
            func(...args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

function parseWKT(wkt) {
    return wkt.slice("LINESTRING(".length, -1)
        .split(",")
        .map(c => c.trim().split(" ").map(Number));
}

function getQuery(type) {
    const [a, b] = points;
    return {
        type: type === "truck" ? "truck_jam" : "jam",
        locale: "ru",
        points: [
            { x: a.x, y: a.y, type: "pedo" },
            { x: b.x, y: b.y, type: "pedo" },
        ],
    };
}

async function getDirection(type) {
    if (points.length < 2) return;
    resetButton.textContent = "–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ...";
    const body = getQuery(type);
    try {
        const response = await fetch(`https://catalog.api.2gis.ru/${type}/6.0.0/global?key=${key}`, {
            method: "POST", body: JSON.stringify(body),
        });
        const json = await response.json();
        directionsResult = Array.isArray(json.result) ? json.result : [];
        
        // Automatically select fastest route (first one)
        activeRouteIndex = 0;
        directionItemSelector.innerHTML = '<option value="0">–ë—ã—Å—Ç—Ä—ã–π –º–∞—Ä—à—Ä—É—Ç</option>';
        directionItemSelector.value = 0;
        
        redrawRoutes();
        resetButton.textContent = "–°–±—Ä–æ—Å–∏—Ç—å";
        startButton.style.display = "block";
        infoPanel.textContent = "–ú–∞—Ä—à—Ä—É—Ç –≥–æ—Ç–æ–≤. –ù–∞–∂–º–∏—Ç–µ –ù–∞—á–∞—Ç—å –Ω–∞–≤–∏–≥–∞—Ü–∏—é.";
    } catch (e) {
        console.error(e);
        resetButton.textContent = "–°–±—Ä–æ—Å–∏—Ç—å";
        infoPanel.textContent = "–û—à–∏–±–∫–∞ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∞";
    }
}

function clearRoutes() {
    drawnRoutes.forEach(r => r.polylines.forEach(p => p.destroy()));
    drawnRoutes = [];
}

function drawRoute(route, index) {
    const isActive = index === activeRouteIndex;
    const color = isActive ? '#0078ff' : '#bfbfbf';
    const drawn = { polylines: [] };
    route.maneuvers.forEach(m => {
        if (m.outcoming_path) {
            m.outcoming_path.geometry.forEach(g => {
                const p = new mapgl.Polyline(map, {
                    coordinates: parseWKT(g.selection),
                    color, width: 8, opacity: isActive ? 1 : 0.4,
                });
                drawn.polylines.push(p);
            });
        }
    });
    return drawn;
}

function redrawRoutes() {
    clearRoutes();
    // Only draw active route
    if (directionsResult[activeRouteIndex]) {
        drawnRoutes.push(drawRoute(directionsResult[activeRouteIndex], 0));
    }
    // Clear previous path
    if (previousPolyline) {
        previousPolyline.destroy();
        previousPolyline = null;
    }
    pathCoords = [];
    travelledDistance = 0;
}

function keepOnlyActiveRoute(index) {
    drawnRoutes.forEach((r, i) => {
        if (i !== index) r.polylines.forEach(p => p.destroy());
    });
    if (drawnRoutes[index]) drawnRoutes = [drawnRoutes[index]]; else drawnRoutes = [];
}

// distance (km) - haversine
function distance(p1, p2) {
    const R = 6371;
    const lat1 = p1[1] * Math.PI / 180;
    const lat2 = p2[1] * Math.PI / 180;
    const dLat = (p2[1] - p1[1]) * Math.PI / 180;
    const dLon = (p2[0] - p1[0]) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1) * Math.cos(lat2) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

function distanceToSegment(point, start, end) {
    // approximate by projecting in degrees (good for small segments)
    const px = point[0], py = point[1];
    const x1 = start[0], y1 = start[1];
    const x2 = end[0], y2 = end[1];
    const dx = x2 - x1, dy = y2 - y1;
    const len2 = dx*dx + dy*dy;
    if (len2 === 0) return distance(point, start);
    let t = ((px - x1)*dx + (py - y1)*dy) / len2;
    t = Math.max(0, Math.min(1, t));
    const proj = [ x1 + t*dx, y1 + t*dy ];
    return distance(point, proj);
}

function minDistanceToPath(point, pathCoords) {
    if (!pathCoords || pathCoords.length < 2) return Infinity;
    let minD = Infinity;
    for (let i = 0; i < pathCoords.length - 1; i++) {
        const d = distanceToSegment(point, pathCoords[i], pathCoords[i+1]);
        if (d < minD) minD = d;
    }
    return minD;
}

// bearing
function getBearing(start, end) {
    const startLat = start[1] * Math.PI / 180;
    const startLng = start[0] * Math.PI / 180;
    const endLat = end[1] * Math.PI / 180;
    const endLng = end[0] * Math.PI / 180;
    const dLng = endLng - startLng;
    const y = Math.sin(dLng) * Math.cos(endLat);
    const x = Math.cos(startLat) * Math.sin(endLat) -
              Math.sin(startLat) * Math.cos(endLat) * Math.cos(dLng);
    let bearing = Math.atan2(y, x) * 180 / Math.PI;
    return (bearing + 360) % 360;
}

// update info panel (keeps existing logic minimal)
function updateInfoPanelSimple() {
    const total = directionsResult[activeRouteIndex] ? totalDistanceFromRoute(directionsResult[activeRouteIndex]) : 0;
    const remaining = Math.max(0, total - travelledDistance);
    infoPanel.textContent =
        `–ü—Ä–æ–π–¥–µ–Ω–æ: ${travelledDistance.toFixed(3)} –∫–º\n` +
        `–û—Å—Ç–∞–ª–æ—Å—å (–ø–æ –º–∞—Ä—à—Ä—É—Ç—É): ${remaining.toFixed(3)} –∫–º\n` +
        (isNavigating ? `–ù–∞–≤–∏–≥–∞—Ü–∏—è: –í–∫–ª—é—á–µ–Ω–∞` : `–ù–∞–≤–∏–≥–∞—Ü–∏—è: –û–∂–∏–¥–∞–Ω–∏–µ`);
}
function totalDistanceFromRoute(route) {
    const coords = [];
    route.maneuvers.forEach(m => {
        if (m.outcoming_path) m.outcoming_path.geometry.forEach(g => coords.push(...parseWKT(g.selection)));
    });
    let sum = 0;
    for (let i=0;i<coords.length-1;i++) sum += distance(coords[i], coords[i+1]);
    return sum;
}

// camera follow strictly behind (throttled)
const throttledCamera = throttle((pos, bearing) => {
    map.setCenter(pos, { duration: CAMERA_UPDATE_INTERVAL });
    if (is3dMode) {
        map.setRotation(bearing, { duration: CAMERA_UPDATE_INTERVAL });
        map.setPitch(60, { duration: CAMERA_UPDATE_INTERVAL });
        map.setZoom(FOLLOW_ZOOM, { duration: CAMERA_UPDATE_INTERVAL });
    }
}, CAMERA_UPDATE_INTERVAL);

// draw/update real path (throttled)
const throttledDrawPath = throttle((coords) => {
    if (previousPolyline) previousPolyline.destroy();
    if (coords.length >= 2) {
        previousPolyline = new mapgl.Polyline(map, {
            coordinates: coords,
            color: "#00aa00",
            width: 4,
            opacity: 0.9,
        });
    }
}, 800);

// –°–æ–∑–¥–∞—ë–º/–æ–±–Ω–æ–≤–ª—è–µ–º –ø—É–Ω–∫—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –º–∞—Ä—à—Ä—É—Ç–∞
function setDestination(lng, lat) {
    // —É–¥–∞–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –º–∞—Ä–∫–µ—Ä—ã –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è (–Ω–µ —Ç—Ä–æ–≥–∞–µ–º userMarker)
    markers.forEach(m => m.destroy());
    markers = [];

    points[1] = { x: lng, y: lat };

    const destMarker = new mapgl.Marker(map, {
        coordinates: [lng, lat],
        color: 'red',
    });
    markers.push(destMarker);

    // –ó–∞–ø—Ä–æ—Å –º–∞—Ä—à—Ä—É—Ç–∞
    getDirection(directionTypeSelector.value);
}

// –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞/—Ç–∞—á–∞
map.on("click", (e) => {
    if (isNavigating) return;
    const [lng, lat] = e.lngLat || [e.lng, e.lat];
    if (!points[0]) {
        if (userMarker) {
            const coords = userMarker.getCoordinates();
            points[0] = { x: coords[0], y: coords[1] };
        } else {
            points[0] = { x: lng, y: lat };
        }
    }
    setDestination(lng, lat);
});

// –ù–∞–¥—ë–∂–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ touch –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö
map.on("touchend", (e) => {
    if (isNavigating) return;
    const touch = (e.changedTouches && e.changedTouches[0]) ||
                  (e.touches && e.touches[0]) ||
                  (e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]);
    if (!touch) return;
    const p = map.unproject([touch.clientX, touch.clientY]);
    if (!p) return;
    const lng = p.lng, lat = p.lat;
    if (!points[0]) {
        if (userMarker) {
            const coords = userMarker.getCoordinates();
            points[0] = { x: coords[0], y: coords[1] };
        } else {
            points[0] = { x: lng, y: lat };
        }
    }
    setDestination(lng, lat);
});

// Start navigation button
startButton.onclick = () => {
    if (!points[1]) {
        infoPanel.textContent = "–í—ã–±–µ—Ä–∏—Ç–µ –ø—É–Ω–∫—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è";
        return;
    }
    // ensure we have A
    if (!points[0]) {
        if (userMarker) {
            const coords = userMarker.getCoordinates();
            points[0] = { x: coords[0], y: coords[1] };
        } else {
            infoPanel.textContent = "–û–∂–∏–¥–∞–Ω–∏–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è...";
            return;
        }
    }

    isNavigating = true;
    cameraFollowing = true;
    startButton.style.display = "none";
    infoPanel.textContent = "–ù–∞–≤–∏–≥–∞—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞";
    updateInfoPanelSimple();
};

resetButton.onclick = () => {
    // clear state
    points = [];
    markers.forEach(m => m.destroy()); markers = [];
    directionsResult = []; clearRoutes();
    if (previousPolyline) { previousPolyline.destroy(); previousPolyline = null; }
    if (userMarker) { userMarker.destroy(); userMarker = null; }
    pathCoords = []; lastPos = null; travelledDistance = 0;
    isNavigating = false;
    startButton.style.display = "none";
    infoPanel.textContent = "üöó –û–∂–∏–¥–∞–Ω–∏–µ —Ç–æ—á–µ–∫...";
    if (watchId) { navigator.geolocation.clearWatch(watchId); watchId = null; }
    startGeolocation();
};

// toggle 3D
toggle3dButton.onclick = () => {
    is3dMode = !is3dMode;
    map.setPitch(is3dMode ? 45 : 0);
};

// Geolocation watcher
function startGeolocation() {
    if (!navigator.geolocation) {
        infoPanel.textContent = "–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –±—Ä–∞—É–∑–µ—Ä–æ–º";
        return;
    }

    const options = { enableHighAccuracy: true, maximumAge: 1000, timeout: 5000 };

    watchId = navigator.geolocation.watchPosition((position) => {
        const { latitude, longitude } = position.coords;
        const userPos = [longitude, latitude];

        // create marker first time
        if (!userMarker) {
            userMarker = new mapgl.Marker(map, {
                coordinates: userPos,
                icon: CAR_ICON,
                size: [32, 32], // larger size for car icon
                rotation: 0 // will be updated based on movement
            });
        } else {
            userMarker.setCoordinates(userPos);
        }

        // update rotation based on movement
        if (lastPos) {
            const bearing = getBearing(lastPos, userPos);
            userMarker.setRotation(bearing);
        }

        // initial A
        if (!points[0]) {
            points[0] = { x: longitude, y: latitude };
            map.setCenter(userPos);
            map.setZoom(15);
        }

        // update travelled path
        if (lastPos) {
            travelledDistance += distance(lastPos, userPos);
        }
        lastPos = userPos;
        pathCoords.push(userPos);
        throttledDrawPath(pathCoords);
        updateInfoPanelSimple();

        // if navigation started => camera follow behind
        if (isNavigating && cameraFollowing) {
            // bearing needs previous point; if not available, try next approach: use route's first segment
            let bearing = 0;
            if (lastPos && pathCoords.length >= 2) {
                // last two points
                const a = pathCoords[Math.max(0, pathCoords.length - 2)];
                const b = pathCoords[pathCoords.length - 1];
                bearing = getBearing(a, b);
            } else if (directionsResult[activeRouteIndex]) {
                // fallback: bearing from route start
                const route = directionsResult[activeRouteIndex];
                const coords = [];
                route.maneuvers.forEach(m => m.outcoming_path?.geometry?.forEach(g => coords.push(...parseWKT(g.selection))));
                if (coords.length >= 2) bearing = getBearing(coords[0], coords[1]);
            }
            throttledCamera(userPos, bearing);
        }

        // if route exists, check deviation -> recalc
        if (directionsResult.length && directionsResult[activeRouteIndex]) {
            // build coords of active route (cached would be better)
            const routeCoords = [];
            const r = directionsResult[activeRouteIndex];
            r.maneuvers.forEach(m => m.outcoming_path?.geometry?.forEach(g => routeCoords.push(...parseWKT(g.selection))));
            const deviation = minDistanceToPath(userPos, routeCoords);
            if (deviation > DEVIATION_THRESHOLD_KM) {
                // recalc route from current position
                points[0] = { x: longitude, y: latitude };
                getDirection(directionTypeSelector.value);
            }
        }

    }, (err) => {
        console.error('geolocation error', err);
        infoPanel.textContent = "–û—à–∏–±–∫–∞ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏";
    }, options);
}

// auto start geolocation
startGeolocation();

// utility: compute min distance to path (uses distance function)
function minDistanceToPath(point, path) {
    if (!path || path.length < 2) return Infinity;
    let minD = Infinity;
    for (let i = 0; i < path.length - 1; i++) {
        const d = distanceToSegment(point, path[i], path[i+1]);
        if (d < minD) minD = d;
    }
    return minD;
}
function distanceToSegment(point, a, b) {
    // reuse small-euclidean projection then haversine
    const px = point[0], py = point[1];
    const x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1];
    const dx = x2 - x1, dy = y2 - y1;
    const len2 = dx*dx + dy*dy;
    if (len2 === 0) return distance(point, a);
    let t = ((px - x1)*dx + (py - y1)*dy) / len2;
    t = Math.max(0, Math.min(1, t));
    const proj = [ x1 + t*dx, y1 + t*dy ];
    return distance(point, proj);
}
</script>
</body>

</html>
